diff -U 3 -H -d -r -N -x .git -x .svn -- yaws-1.90/src/json.erl yaws-1.90.encode_floats/src/json.erl
--- yaws-1.90/src/json.erl	2011-05-25 23:33:26.000000000 +0200
+++ yaws-1.90.encode_floats/src/json.erl	2011-05-31 17:34:58.588522932 +0200
@@ -79,7 +79,6 @@
 %%% syntactically valid JSON floating-point numbers could silently
 %%% lose precision or noisily cause an overflow.  However, most
 %%% other JSON libraries are likely to behave in the same way.
-%%% The encoding precision defaults to 6 digits.
 %%%
 %%% Strings: If we represented JSON string data as Erlang binaries,
 %%% we would have to choose a particular unicode format.  Instead,
@@ -123,7 +122,7 @@
 encode(undefined) -> "null";
 encode(B) when is_binary(B) -> encode_string(B);
 encode(I) when is_integer(I) -> integer_to_list(I);
-encode(F) when is_float(F) -> io_lib:format("~g", [F]);
+encode(F) when is_float(F) -> erlang:float_to_list(F);
 encode(L) when is_list(L) ->
     case is_string(L) of
 	yes -> encode_string(L);
@@ -309,7 +308,7 @@
     % Note that nonzero numbers can't start with "0".
     scan_number(Ds, 10 * A + (D - $0), X);
 scan_number([D | Ds], A, X) when D == $E; D == $e ->
-    scan_exponent_begin(Ds, float(A), X);
+    scan_exponent_begin(Ds, integer_to_list(A) ++ ".0", X);
 scan_number([D | _] = Ds, A, _X) when D < $0; D > $9 ->
     {done, {ok, A}, Ds}.
 
@@ -317,15 +316,15 @@
 
 scan_fraction([], _Fs, _I, X) -> {more, X};
 scan_fraction(eof, Fs, I, _X) ->
-    R = I + list_to_float("0." ++ lists:reverse(Fs)),
+    R = list_to_float(lists:append([integer_to_list(I), ".", lists:reverse(Fs)])),
     {done, {ok, R}, eof};
 scan_fraction([D | Ds], Fs, I, X) when D >= $0, D =< $9 ->
     scan_fraction(Ds, [D | Fs], I, X);
 scan_fraction([D | Ds], Fs, I, X) when D == $E; D == $e ->
-    R = I + list_to_float("0." ++ lists:reverse(Fs)),
+    R = lists:append([integer_to_list(I), ".", lists:reverse(Fs)]),
     scan_exponent_begin(Ds, R, X);
 scan_fraction(Rest, Fs, I, _X) ->
-    R = I + list_to_float("0." ++ lists:reverse(Fs)),
+    R = list_to_float(lists:append([integer_to_list(I), ".", lists:reverse(Fs)])),
     {done, {ok, R}, Rest}.
 
 scan_exponent_begin(Ds, R, X) ->
@@ -340,12 +339,12 @@
 
 scan_exponent([], _Es, _R, X) -> {more, X};
 scan_exponent(eof, Es, R, _X) ->
-    X = R * math:pow(10, list_to_integer(lists:reverse(Es))),
+    X = list_to_float(lists:append([R, "e", lists:reverse(Es)])),
     {done, {ok, X}, eof};
 scan_exponent([D | Ds], Es, R, X) when D >= $0, D =< $9 ->
     scan_exponent(Ds, [D | Es], R, X);
 scan_exponent(Rest, Es, R, _X) ->
-    X = R * math:pow(10, list_to_integer(lists:reverse(Es))),
+    X = list_to_float(lists:append([R, "e", lists:reverse(Es)])),
     {done, {ok, X}, Rest}.
 
 scan_comment([]) -> {more, "/"};
diff -U 3 -H -d -r -N -x .git -x .svn -- yaws-1.90/src/json2.erl yaws-1.90.encode_floats/src/json2.erl
--- yaws-1.90/src/json2.erl	2011-05-25 23:33:26.000000000 +0200
+++ yaws-1.90.encode_floats/src/json2.erl	2011-05-31 17:35:16.730508415 +0200
@@ -50,7 +50,6 @@
 %%% syntactically valid JSON floating-point numbers could silently
 %%% lose precision or noisily cause an overflow.  However, most
 %%% other JSON libraries are likely to behave in the same way.
-%%% The encoding precision defaults to 6 digits.
 %%%
 %%% Strings: If we represented JSON string data as Erlang binaries,
 %%% we would have to choose a particular unicode format.  Instead,
@@ -82,7 +81,7 @@
 encode(undefined) -> "null";
 encode(B) when is_binary(B) -> encode_string(B);
 encode(I) when is_integer(I) -> integer_to_list(I);
-encode(F) when is_float(F) -> io_lib:format("~g", [F]);
+encode(F) when is_float(F) -> erlang:float_to_list(F);
 encode(L) when is_list(L) ->
     case is_string(L) of
 	yes -> encode_string(L);
@@ -264,7 +263,7 @@
     % Note that nonzero numbers can't start with "0".
     scan_number(Ds, 10 * A + (D - $0), X);
 scan_number([D | Ds], A, X) when D == $E; D == $e ->
-    scan_exponent_begin(Ds, float(A), X);
+    scan_exponent_begin(Ds, integer_to_list(A) ++ ".0", X);
 scan_number([D | _] = Ds, A, _X) when D < $0; D > $9 ->
     {done, {ok, A}, Ds}.
 
@@ -272,15 +271,15 @@
 
 scan_fraction([], _Fs, _I, X) -> {more, X};
 scan_fraction(eof, Fs, I, _X) ->
-    R = I + list_to_float("0." ++ lists:reverse(Fs)),
+    R = list_to_float(lists:append([integer_to_list(I), ".", lists:reverse(Fs)])),
     {done, {ok, R}, eof};
 scan_fraction([D | Ds], Fs, I, X) when D >= $0, D =< $9 ->
     scan_fraction(Ds, [D | Fs], I, X);
 scan_fraction([D | Ds], Fs, I, X) when D == $E; D == $e ->
-    R = I + list_to_float("0." ++ lists:reverse(Fs)),
+    R = lists:append([integer_to_list(I), ".", lists:reverse(Fs)]),
     scan_exponent_begin(Ds, R, X);
 scan_fraction(Rest, Fs, I, _X) ->
-    R = I + list_to_float("0." ++ lists:reverse(Fs)),
+    R = list_to_float(lists:append([integer_to_list(I), ".", lists:reverse(Fs)])),
     {done, {ok, R}, Rest}.
 
 scan_exponent_begin(Ds, R, X) ->
@@ -295,12 +294,12 @@
 
 scan_exponent([], _Es, _R, X) -> {more, X};
 scan_exponent(eof, Es, R, _X) ->
-    X = R * math:pow(10, list_to_integer(lists:reverse(Es))),
+    X = list_to_float(lists:append([R, "e", lists:reverse(Es)])),
     {done, {ok, X}, eof};
 scan_exponent([D | Ds], Es, R, X) when D >= $0, D =< $9 ->
     scan_exponent(Ds, [D | Es], R, X);
 scan_exponent(Rest, Es, R, _X) ->
-    X = R * math:pow(10, list_to_integer(lists:reverse(Es))),
+    X = list_to_float(lists:append([R, "e", lists:reverse(Es)])),
     {done, {ok, X}, Rest}.
 
 %%% PARSING
