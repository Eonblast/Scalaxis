addOnloadHook(function () {

    /**
     * Find any inflection tables on the current page.
     */
    function find_inflection_tables () {
        if (typeof(document.getElementsByClassName) == 'function') {
            return document.getElementsByClassName ('inflection-table');
        } else {
            var tables = document.getElementsByTagName ('table');
            var form_ofs = new Array ();
            
            for (var i=0; i<tables.length; i++) {
                if (tables[i].className.match(/(^| +)inflection-table( +|$)/)) {
                    form_ofs.push (tables[i]);
                }
            }
            
            return form_ofs;
        }
    }

    /**
     * Look inside an inflect_table to see if there are any redlinks we can
     * turn green
     */
    function process_inflection_table (table) {
        
        var classnames = table.className.split(" ");

        var inflection_line;
        var part_of_speech;

        for (var i=0; i< classnames.length; i++) {
            
            if (classnames[i].indexOf("inflection-") == 0 &&
                    classnames[i] != "inflection-table") {

                inflection_line = parse_inflection_line(unanchor_encode(classnames[i]));
                part_of_speech = parse_part_of_speech(unanchor_encode(classnames[i]));
            }
        }

        if (! (inflection_line && part_of_speech)) 
            return;

        
        var form_ofs = find_form_ofs(table);

        for (var i=0; i<form_ofs.length; i++) {

            process_form_of(form_ofs[i], inflection_line, part_of_speech);

        }
    }

    /**
     * Parse inflection table class name (generated by { {Creation helper} })
     */
    function parse_inflection_line(classname) {

        var parts = classname.replace("inflection-","").replace(/(-~)*$/,"").split("-");
        if (parts[0] && parts[0] == "third" && parts[1] && parts[1] == "person singular")
            parts = parts.splice(0,2,"third-person singular");
        var inflection_line = "{{"+parts.join("|")+"}}";
        return inflection_line;

    }
    /**
     * Extract the part of speech header from the inflection class name
     */
    function parse_part_of_speech(classname) {

        var pos = classname.replace("inflection-","").replace(/[0-9]?-.+$/,"");
        pos = pos.charAt(0).toUpperCase() + pos.substr(1);
        return "=="+pos+"==";

    }
    /**
     * Iterate over the inflection table to find red-links in form-of spans
     */
    function find_form_ofs(table) {

        if (typeof(table.getElementsByClassName) == 'function') {
            return table.getElementsByClassName ('form-of');
        } else {
            var spans = table.getElementsByTagName ('span');
            var form_ofs = new Array ();
            
            for (var i=0; i<spans.length; i++) {
                if (spans[i].className.match(/(^| +)form-of( +|$)/)) {
                    form_ofs.push (spans[i]);
                }
            }
            
            return form_ofs;
        }
    }

    function process_form_of(form_of, inflection_line, part_of_speech)
    {

        var classnames = form_of.className.split(/\s+/);

        var definition_line;

        for (var i=0; i<classnames.length; i++) {

            if (classnames[i].indexOf('-form-of-') > 0) {
                definition_line = parse_definition_line(unanchor_encode(classnames[i]));
            }

        }

        var link = find_red_link(form_of);

        if (! (definition_line && link))
            return;

        register_creation(link, definition_line, inflection_line, part_of_speech);
    }

    function unanchor_encode(text) {

        return unescape(text.replace(/\.([0-9A-F][0-9A-F])/g, "%$1")).replace(/&amp;/g,"&").replace(/_/g," ");

    }

    /**
     * Extract a definition line created by { {creatable} }
     */
    function parse_definition_line(classname) {
        var parts = classname.split("-form-of-");
        return "# {" + "{"+parts[0]+" of|"+parts[1]+"}}";
    }
    /**
     * Recursively find first red link in "form-of" spans.
     */
    function find_red_link (span) {
        
        var poss = span.firstChild;

        while (poss) {
            if(poss.nodeType == 1) {
                if (poss.nodeName.toUpperCase () == 'A' && poss.className.indexOf('new') >= 0) 
                    return poss;
                else if (recurse = find_red_link(poss)) 
                    return recurse;
            }
            poss = poss.nextSibling;
        }

        return null;
    }

    /**
     * Add a definition to be created later
     */
    function register_creation (link, definition_line, inflection_line, part_of_speech) {

        links_to_create.push(link);

        var to_create = pages_to_create[link.href] || {};

        var heading = part_of_speech+"\n"+inflection_line;

        if (to_create[heading]) {
            if (to_create[heading].indexOf("past tense of") >= 0 && definition_line.indexOf("past participle of"))
                to_create[heading] = to_create[heading].replace("past tense of", "past tense and participle of");
            else if (to_create[heading].indexOf("past participle of") >= 0 && definition_line.indexOf("past tense of"))
                to_create[heading] = to_create[heading].replace("past participle of", "past tense and participle of");
            else
                to_create[heading] += "\n" + definition_line;
        } else
            to_create[heading] = definition_line;

        pages_to_create[link.href] = to_create;
    }

    /**
     * Create the page we are to create.
     */
    function assemble_page(obj) {

        var output = "";
        for (var heading in obj) {

            output += heading + "\n" + obj[heading] + "\n\n";

        }
        return output + "[" + "[en:{" + "{subst:PAGENAME}}]]\n";

    }

    /**
     * Summarise the edit we just made
     */
    function assemble_summary(obj)
    {
        var output = "Creating "
        var comma = "";
        for (var heading in obj) {

            var lines = obj[heading].split("\n");
            for (var i=0; i<lines.length; i++) {
                output += comma + lines[i].replace("# {{","").replace(/of\|.+$/,"");
                comma = "+ ";
            }
        }
        return output + "from " + wgTitle + " ([[User talk:Conrad.Irwin/creation.js|Accelerated]])"

    } 

    var pages_to_create = {};
    var links_to_create = [];

    var tables = find_inflection_tables()

    for (var i=0; i< tables.length; i++) {

        process_inflection_table (tables[i]);

    }

    for (var i=0; i<links_to_create.length; i++) {
        var link = links_to_create[i];

        link.href += "&preloadtext=" + escape(assemble_page(pages_to_create[link.href]))
                  +  "&preloadsummary=" + escape(assemble_summary(pages_to_create[link.href]));
        link.style.cssText = "color: #22CC00";

    }
    
});

/* ************************************************************************* */

/**
 * A function from [[en:User:Visviva/pretext.js]] to allow arbitrary
 * text to be inserted into the edit box through the URL.
 *
 * Visit a url of the form ?action=edit&preloadtext=<something>&preloadsummary=
 */
function preloadText() { 
    var pretext="";
    var presummary="";
    var parts;
    if (window.location.search.indexOf('?') > -1) {
        parts=window.location.search.split("?")[1].split("&")
    } else {
        return; //not an edit page
    }
    
    for (p in parts) {
        pair=parts[p].split("=")
        if (pair[0]=="preloadtext") {
            pretext=unescape(pair[1])
        }else if (pair[0]=="preloadsummary") {
            presummary=unescape(pair[1])
        }
    }
    if (pretext != ""){
        if (document.editform.wpTextbox1.value != ""){
            pretext+="\n\n"
        }
        pretext=pretext+document.editform.wpTextbox1.value
        document.editform.wpTextbox1.value=pretext
    }

    if (presummary != "") {
        document.editform.wpSummary.value += presummary;
    }
}

addOnloadHook( preloadText );