%  Copyright 2007-2008 Konrad-Zuse-Zentrum für Informationstechnik Berlin
%
%   Licensed under the Apache License, Version 2.0 (the "License");
%   you may not use this file except in compliance with the License.
%   You may obtain a copy of the License at
%
%       http://www.apache.org/licenses/LICENSE-2.0
%
%   Unless required by applicable law or agreed to in writing, software
%   distributed under the License is distributed on an "AS IS" BASIS,
%   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
%   See the License for the specific language governing permissions and
%   limitations under the License.
\documentclass[a4]{scrbook}
\usepackage{typearea}
\areaset[1cm]{165mm}{240mm}

\usepackage[OT1]{fontenc}
\usepackage[latin1]{inputenc}

\usepackage{relsize}
\usepackage{graphicx}
%\usepackage{color}
%\usepackage{colortbl}
\usepackage{longtable}
\usepackage{makeidx}
\usepackage{fancyhdr}
\usepackage{fancyvrb}
\usepackage{lastpage}
\usepackage{xcolor}

\usepackage[pdftex,
        colorlinks=true,
        urlcolor=rltblue,       % \href{...}{...} external (URL)
        filecolor=rltblue,     % \href{...} local file
        linkcolor=rltblue,      % \ref{...} and \pageref{...}
%        pagebackref=true,
        pdfborder={0 0 0}]{hyperref}
\usepackage{listings}

\renewcommand{\headrulewidth}{0pt}    % Width of head rule
\renewcommand{\footrulewidth}{0.3pt}  % Width of head rule

% normal pages
\pagestyle{fancy}
\fancyhf{} % clear all header and footer fields
%\fancyhead[RE,LO]{}
\fancyhead[RO]{}%
\fancyfoot[LE,RO]{\bfseries\thepage\ / \pageref{LastPage}}%
\chead{}%
\cfoot{}%

% beginning of a chapter
\fancypagestyle{plain}{%
\fancyhf{} % clear all header and footer fields
%\fancyhead[RE,LO]{}
\fancyhead[RO]{}%
\fancyfoot[LE,RO]{\bfseries\thepage\ / \pageref{LastPage}}%
\chead{}%
\cfoot{}%
}

% Clear Header Style on the Last Empty Odd pages
\makeatletter
\def\cleardoublepage{\clearpage\if@twoside \ifodd\c@page\else%
    \hbox{}%
    \thispagestyle{empty}%              % Empty header styles
    \newpage%
    \if@twocolumn\hbox{}\newpage\fi\fi\fi}
\makeatother

%% Bold typewriter font
\renewcommand{\ttdefault}{pcr}

%%% colors %%%%%%%%%%%%%%%%%%%%%%%%

\definecolor{lightyellow}{rgb}{1.0, 1.0, 0.5}
\definecolor{rltred}{rgb}{0.75,0,0}
\definecolor{rltgreen}{rgb}{0,0.5,0}
\definecolor{rltblue}{rgb}{0,0,0.75}
\definecolor{lightgray}{gray}{0.9}

\setlength{\parindent}{0pt}

\definecolor{lightyellow}{rgb}{1.0, 1.0, 0.5}
\definecolor{codebackground}{rgb}{0.96,0.96,0.8}
\definecolor{commandinput}{rgb}{0.8,0.8,1}

%\thicklines
\lstset{
  basicstyle=\scriptsize\ttfamily,
  backgroundcolor=\color{codebackground},
  keywordstyle=\color{blue}\bfseries,
  % underlined bold black keywords
  identifierstyle=\bfseries, % nothing happens
  commentstyle=\color{red}\bfseries, % white comments
  stringstyle=\sffamily, % typewriter type for strings
  showstringspaces=false,
  xleftmargin=3pt,
  xrightmargin=3pt,
  fancyvrb=true,
  frame=single,
%  frameround=tttt,
%  framexleftmargin=0pt,
  framextopmargin=3pt,
  framexbottommargin=3pt,
%  framexrightmargin=5pt,
  rulecolor=\color{codebackground},
  language=Erlang,
%  fillcolor=\color{red},
%  rulesepcolor=\color{black}
%  rulesep=1cm,
}
\lstset{rangebeginprefix=\%\%\ userdevguide-begin\ }
\lstset{rangeendprefix=\%\%\ userdevguide-end\ }
\lstset{includerangemarker=false}

% \codesnippet[lstsettings]{filename-label}{range-label}{src-file with path}
% \codesnippet[language=Erlang]{admin.erl}{admin:add_nodes}{../src/admin.erl}
\newcommand{\codesnippet}[4][language=Erlang]{
{
\lstset{numbers=left}
\lstinputlisting[
  title=\filetitle{#2},
  linerange=#3-#3,
  #1
]
{#4}
}
}

% \codesfile[lstsettings]{filename-label}{src-file with path}
% \codesfile[language=Erlang]{admin.erl}{../src/admin.erl}
\newcommand{\codefile}[3][language=Erlang]{
{
\lstinputlisting[
  title=\filetitle{#2},
  #1]
{#3}
}
}

\newcommand{\sieheref}[1]{\ref{#1} on page~\pageref{#1}}
\newcommand{\code}[1]{\lstinline[basicstyle=\small\ttfamily]!#1!}
\newcommand{\filetitle}[1]{\hbox to \linewidth{~~File \code{#1:}\hfill}}
\newcommand{\scalaris}{Scalaris}
\newcommand{\todo}[1]{\texttt{\color{red}{#1}}}


\makeindex

\begin{document}
\vspace*{4cm}
\begin{center}
\setlength{\parskip}{0.8cm}
{
\Huge
\bf \textit{\it\sffamily Scalaris}

 \textsf{Users and Developers Guide}

\textsf{Version 0.1}
}

{\LARGE Florian Schintke, Thorsten Schütt}

{\LARGE \today}
\vfill
\end{center}
\pagebreak
\mbox{}
\vfill

Copyright 2007-2008 Konrad-Zuse-Zentrum für Informationstechnik Berlin

\medskip
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

\medskip
\url{http://www.apache.org/licenses/LICENSE-2.0}

\medskip
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

\tableofcontents

\part{Users Guide}

\chapter{Download and Installation}

\section{Requirements}

For building and running \scalaris{}, some third-party modules are
required which are not included in the \scalaris{} sources:

\begin{itemize}
\setlength{\itemsep}{0pt}
\setlength{\parskip}{0pt}
\item Erlang R12
\item Erlang OTP (included in Erlang R12)
\item GNU Make
\end{itemize}

Note, the Version 12 of Erlang is required. \scalaris{} will not
work with older versions.

To build the Java API the following modules are required additionally:

\begin{itemize}
\setlength{\itemsep}{0pt}
\setlength{\parskip}{0pt}
\item Java Development Kit 1.6
\item Apache Ant
\end{itemize}

Before building the Java API, make sure that \code{JAVA\_HOME} and
\code{ANT\_HOME} are set. \code{JAVA\_HOME} has to point to a JDK
1.6 installation, and \code{ANT\_HOME} has to point to an Ant
installation.

\section{Download}

The sources can be obtained from \url{http://code.google.com/p/scalaris}.

\subsection{Development Branch}

You find the latest development version in the svn repository:
\begin{lstlisting}[language=sh]
# Non-members may check out a read-only working copy anonymously over HTTP.
svn checkout http://scalaris.googlecode.com/svn/trunk/ scalaris-read-only
\end{lstlisting}

\subsection{Releases}

Releases can be found under the 'Download' tab on the web-page.


\section{Configuration}

\scalaris{} reads two configuration files from the working directory:
\code{bin/scalaris.cfg} (mandatory) and \code{bin/scalaris.local.cfg}
(optional). The former defines default settings and is included in the
release. The latter can be created by the user to alter settings.  A sample
file is \code{bin/scalaris.local.cfg.example}. A local configuration file is
necessary to run \scalaris{} on distributed nodes:

\codefile{scalaris.local.cfg}{../bin/scalaris.local.cfg.example}

\code{boot_host} defines the node where the boot server is running, which is
contacted to join the system.

\section{Build}

%\subsection{Windows (Win32)}
% \begin{enumerate}
% \setlength{\itemsep}{0pt}
% \setlength{\parskip}{0pt}
% \item Copy \code{make.exe} from \code{contrib/win32} to \code{src} 
% \item Copy \code{Makefile_to_src} from \code{contrib/win32} to \code{src} 
% \item Copy \code{Makefile_to_src_comm_layer} from \code{contrib/win32} to \code{src/comm_layer} 
% \item Copy \code{Makefile_to_src_transstore} from \code{contrib/win32} to \code{src/transstore} 
% \item Rename Makefiles
% \item Open MS-DOS Command Shell 
% \item Go into \code{src} directory 
% \item Call \code{make}
% \item Go into bin directory 
% \item Call \code{boot.bat}
% \end{enumerate}
% 
% \subsubsection{Troubleshooting}
% Check path to Erlang Installation in Makefiles.

\subsection{Linux}

\scalaris{} uses autoconf for configuring the build environment and
GNU Make for building the code.

\begin{lstlisting}[language=sh]
%> ./configure
%> make
%> make docs
\end{lstlisting}

For more details read \code{README} in the main \scalaris{} checkout
directory.

\subsection{Windows}

We are currently not supporting \scalaris{} on Windows. However, we
have two small {\tt bat} files for building and running a boot
server. It seems to work but we make no guarantees.

\begin{itemize}
\item Install Erlang
\item Install OpenSSL (for crypto module)
\item Checkout scalaris code from SVN
\item copy an appropriate EMakefile\_for from \code{contrib/win32} to the trunk-directory
\item Adapt the path to your Erlang installation in build.bat
\item run build.bat
\item Go to the bin sub-directory
\item Adapt the path to your Erlang installation in boot.bat
\item run boot.bat
\end{itemize}


\subsection{Java-API}

The following commands will build the Java API for \scalaris{}:
\begin{lstlisting}[language=sh]
%> make java
\end{lstlisting}

This will build scalaris.jar, which is the library for accessing
the overlay network. Optionally, the documentation can be build:
\begin{lstlisting}[language=sh]
%> cd java-api
%> ant doc
\end{lstlisting}


\section{Running \scalaris{}}

In \scalaris{} there are two kinds of processes:
\begin{itemize}
\setlength{\itemsep}{0pt}
\setlength{\parskip}{0pt}
\item boot servers
\item regular servers
\end{itemize}

In every \scalaris{}, at least one boot server is required. It will
maintain a list of nodes taken part in the system and allows other
nodes to join the ring. For redundancy, it is also possible to have
several boot servers.

\subsection{Running on a local machine}
\label{sec.boot}

Open at least two shells. In the first, go into the bin directory:
\begin{lstlisting}[language=sh]
%> cd bin
%> ./boot.sh
\end{lstlisting}

This will start the boot server. On success \url{http://localhost:8000}
should point to the management interface page of the boot server. The main
page will show you the number of nodes currently in the system. After a
couple of seconds a first \scalaris{} should have started in the boot server
and the number should increase to one. The main page will also allow you to
store and retrieve key-value pairs.

%The boot server should show output similar to the following, when
%starting the first \scalaris{} nodes. The first line is printed when
%the \scalaris{} is spawned. Afterwards it will try to connect the
%boot server. When the third line is printed, it managed to contact the
%boot server and joined the ring. In this case, it was the first node
%in the ring.
%\begin{lstlisting}
%[ I | Node   | <0.97.0> ] joining "23947834870"
%[ I | Node   | <0.97.0> ] join as first [50,51,57,52,55,56,51,52,56,55,48]
%[ I | Node   | <0.97.0> ] joined
%\end{lstlisting}

In a second shell, you can now start a second \scalaris{} node. This
will be a `regular server'. Go in the bin directory:
\begin{lstlisting}[language=sh]
%> cd bin
%> ./cs_local.sh
\end{lstlisting}

The second node will read the configuration file and use this
information to contact the boot server and will join the ring. The
number of nodes on the web page should have increased to two by now.

Optionally, a third and fourth node can be started on the same
machine. In a third shell:
\begin{lstlisting}[language=sh]
%> cd bin
%> ./cs_local2.sh
\end{lstlisting}


In a fourth shell:
\begin{lstlisting}[language=sh]
%> cd bin
%> ./cs_local3.sh
\end{lstlisting}


This will add 3 nodes to the network. The web pages at
\url{http://localhost:8000} should show the additional nodes.

\subsection{Running distributed}

\scalaris{} can be installed on other machines in the same way as
described in Sect.~\ref{sec:install}. In the default configuration,
nodes will look for the boot server on localhost on port 14195. You
should create a \code{scalaris.local.cfg} pointing to the node running
the boot server.

\begin{lstlisting}[language=Erlang]
% Insert the appropriate IP-addresses for your setup
% as comma separated integers:
% IP Address, Port, and label of the boot server
{boot_host, {{127,0,0,1},14195,boot}}.
\end{lstlisting}

If you are using the default configuration on the boot server it will
listen on port 14195 and you only have to change the IP address in the
configuration file. Otherwise the other nodes will not find the boot
server. On the remote nodes, you only need to call
\code{./cs_local.sh} and they will automatically contact the
configured boot server.

%\subsection{Running on PlanetLab}

%\subsection{Replication Degree}

%\subsection{Routing Scheme}

\section{Installation}
\label{sec:install}

For simple tests, you do not need to install \scalaris{}. You can run
it directly from the source directory. Note: \code{make install} will
install scalaris into \code{/usr/local}. But is more convenient to
build RPMs and install those.

\begin{lstlisting}{language=sh}
svn checkout http://scalaris.googlecode.com/svn/trunk/ scalaris-0.0.1
tar -cvjf scalaris-0.0.1.tar.bz2 scalaris-0.0.1 --exclude-vcs
cp scalaris-0.0.1.tar.bz2 /usr/src/packages/SOURCES/
rpmbuild -ba scalaris-0.0.1/contrib/scalaris.spec
\end{lstlisting}

Your source and binary rpm will be generated in
/usr/src/packages/SRPMS and RPMS.  We also build rpms using checkouts
from svn and provide them using the openSUSE BuildService at
http://download.opensuse.org/repositories/home:/tschuett/. RPM
packages are available for

\begin{itemize}
\item Fedora 9, 10,
\item Mandriva 2008, 2009,
\item openSUSE 11.0, 11.1,
\item SLE 10, 11,
\item CentOS 5 and
\item RHEL 5.
\end{itemize}

Inside those repositories you will also find an erlang rpm - you don't
need this if you already have a recent enough erlang version!

\section{Logging}
\label{sec:logging}

\scalaris{} uses the log4erl library (see \code{contrib/log4erl} for
logging status information and error messages. The log level can be
configured in \code{bin/scalaris.cfg}.  The default value is {\tt
  error}; only errors and severe problems are logged.

\begin{lstlisting}[language=Erlang]
%% @doc Loglevel: debug < info < warn < error < fatal < none
{log_level, error}.
\end{lstlisting}

In some cases, it might be necessary to get more complete logging
information, e.g. for debugging. In \sieheref{sec:start-addit-local},
we are explaining the startup process of \scalaris nodes in more
detail, here the {\tt info} level provides more detailed information.

\begin{lstlisting}[language=Erlang]
%% @doc Loglevel: debug < info < warn < error < fatal < none
{log_level, info}.
\end{lstlisting}

\chapter{Using the system}

\section{JSON API}

\scalaris{} supports a JSON API for transactions. To minimize the necessary
round trips between a client and \scalaris{}, it uses request lists, which
contain all requests that can be done in parallel. The request list is then
send over to a \scalaris{} node with a POST message. The result is an opaque
TransLog and a list containing the results of the requests. To add further
requests to the transaction, the TransLog and another list of requests may
be send to \scalaris{}.  This process may be repeated as necessary. To finish
the transaction, the request list can contain a 'commit' request as last
element, which triggers the validation phase of the transaction processing.

The JSON-API can be accessed via the \scalaris-Web-Server running on port
8000 by default and the page \code{jsonrpc.yaws} (For example at:
\url{http://localhost:8000/jsonrpc.yaws}).  The following example
illustrates the message flow:

\begin{longtable}{p{0.45\textwidth}cp{0.45\textwidth}}
\bf Client & & \bf \scalaris{} node \\
Make a transaction, that sets two keys:
\begin{lstlisting}[language=java]
{
  "method":"req_list",
  "version":"1.1",
  "params":
    [
      [
        { "write":{"keyA":"valueA"} },
        { "write":{"keyB":"valueB"} },
        { "commit":"commit" }
      ]
    ],
  "id":0
}
\end{lstlisting}
& $\to$
& \\

& $\leftarrow$ &
\scalaris{} sends results back
\begin{lstlisting}[language=java]
{ "result":
  { "results":
      [
        { "op":"commit",
          "value":"ok",
          "key":"ok" },
        { "op":"write",
          "value":"valueB",
          "key":"keyB" },
        { "op":"write",
          "value":"valueA",
          "key":"keyA" }
      ],
    "translog":
     [...]
  },
  "id" : 0
}
\end{lstlisting}
\\

In a second transaction: Read the two keys
\begin{lstlisting}[language=java]
{
  "method":"req_list",
  "version":"1.1",
  "params":
    [
      [
        { "read":"keyA" },
        { "read":"keyB" }
      ]
    ]
  "id":0
}
\end{lstlisting}
& $\to$ & \\

& $\leftarrow$ &
\scalaris{} sends results back
\begin{lstlisting}[language=java]
{ "result":
  {"results":
    [
      { "op":"read",
        "value":"valueB",
        "key":"keyB" },
      { "op":"read",
        "value":"valueA",
        "key":"keyA" }
    ],
   "translog":
    [...] // this list is the translog
          // for further operations!
          // We name it TLOG here.
  },
  "id" : 0
}
\end{lstlisting}\\

Calculate something with the read values and make further requests, here a
write and the commit for the whole transaction. Include also the latest
translog we got from \scalaris{} (named \code{TLOG} here).

\begin{lstlisting}[language=java]
{
  "method":"req_list",
  "version":"1.1",
  "params":
    [
      TLOG, // translog from prev. result.
      [
        { "write":{"keyA":"valueA2"} },
        { "commit":"commit" }
      ]
    ],
  "id" : 0
}
\end{lstlisting}
& $\to$ & \\

& $\leftarrow$ &
\scalaris{} sends results back
\begin{lstlisting}[language=java]
{ "result":
  { "results":
    [ { "op":"commit",
        "value":"ok",
        "key":"ok" },
      { "op":"write",
        "value":"valueA2",
        "key":"keyA" }
    ],
    "translog":
    [...]
  },
  "id" : 0
}
\end{lstlisting}\\
\end{longtable}

A sample usage of the JSON API using Ruby can be found in \code{contrib/jsonrpc.rb}.

A single request list must not contain a key more than once!

The allowed requests are:
\begin{lstlisting}[language=java]
{ "read":"any_key" }

{ "write":{"any_key":"any_value"} }

{ "commit":"commit" }
\end{lstlisting}

The possible results are:
\begin{lstlisting}[language=java]
{ "op":"read", "key":"any_key", "value":"any_value" }
{ "op":"read", "key":"any_value", "fail":"reason" } // 'not_found' or 'timeout'

{ "op":"write",  "key":"any_key", "value":"any_value" }
{ "op":"read", "key":"any_key", "fail":"reason" }

{ "op":"commit", "value":"ok", "key":"ok" }
{ "op":"commit", "value":"fail", "fail":"reason" }
\end{lstlisting}

\subsection{Deleting a key}

Outside transactions keys can also be deleted, but it has to be done with
care, as explained in the following thread on the mailing list:
\url{http://groups.google.com/group/scalaris/browse_thread/thread/ff1d9237e218799}.

\begin{lstlisting}[language=java]
{
  "method":"delete",
  "version":"1.1",
  "params":
    [
      { "key":"any_key" }
    ],
  "id" : 0
}
\end{lstlisting}

Two sample results

\begin{lstlisting}[language=java]
{ "result":
  { "ok":2, // how many replicas were deleted successsfully
    "results": [ "ok", "ok", "locks_set", "undef" ]
  }
}
\end{lstlisting}

\begin{lstlisting}[language=java]
{ "result":
  { "failure":"reason" }
}
\end{lstlisting}


%\section{Erlang}

\section{Java command line interface}

The jar file contains a small command line interface client. For
convenience, we provide a wrapper script called \code{scalaris} which
setups the Java environment:

\begin{lstlisting}[language=sh]
%> cd java-api
%> ./scalaris -help
usage: scalaris
 -g,--getsubscribers <topic>   get subscribers of a topic
 -help                         print this message
 -minibench                    run mini benchmark
 -p,--publish <params>         publish a new message for a topic: <topic>
                               <message>
 -r,--read <key>               read an item
 -s,--subscribe <params>       subscribe to a topic: <topic> <url>
 -u,--unsubscribe <params>     unsubscribe from a topic: <topic> <url>
 -w,--write <params>           write an item: <key> <value>
\end{lstlisting}

Read and write can be used to read resp. write from/to the
overlay. getsubscribers, publish, and subscribe are the PubSub
functions.

\begin{lstlisting}[language=sh]
%> ./scalaris -write foo bar
write(foo, bar)
%> ./scalaris -read foo
read(foo) == bar
\end{lstlisting}

The scalaris library requires that you are running a `regular server' on
the same node. Having a boot server running on the same node is not
sufficient.

\section{Java API}

The \code{scalaris.jar} provides the command line client as well as a
library for Java programs to access \scalaris{}. The library provides two classes:

\begin{itemize}
\item \code{Scalaris} provides a high-level API similar to the command line client.
\item \code{Transaction} provides a low-level API to the transaction
  mechanism.
\end{itemize}

For details we refer the reader to the Javadoc:

\begin{lstlisting}[language=sh]
%> cd java-api
%> ant doc
%> firefox doc/index.html
\end{lstlisting}

\chapter{Testing the system}

\section{Running the unit tests}
There are some unit tests in the \code{test} directory. You can call them
by running \code{make test} in the main directory. The results are stored
in a local \code{index.html} file. 

The tests are implemented with the \code{common-test} package from the
Erlang system. For running the tests we rely on \code{run\_test},
which is part of the \code{common-test} package, but is not installed
by default. \code{configure} will check whether \code{run\_test} is
available. If it is not installed, it will show a warning and a short
description of how to install the missing file.

Note: for the unit tests, we are setting up and shutting down several
overlay networks. During the shut down phase, the runtime environment
will print extensive error messages. These error messages do not
indicate that tests failed! Running the complete test suite takes
about 5 minutes. Only when the complete suite finished, it will
present statistics on failed and successful tests.

\part{Developers Guide}

\chapter{How a node joins the system}

\section{General Erlang server loop}

Servers in Erlang often use the following structure to maintain a state
while processing received messages:

\lstset{language=Erlang}
\begin{lstlisting}%[title=\filetitle{foo.erl}]
loop(State) ->
  receive
    Message ->
      State1 = f(State),
      loop(State1)
  end.
\end{lstlisting}

The server runs an endless loop, that waits for a message, processes it and
calls itself using tail-recursion in each branch. The loop works on a
\code{State}, which can be modified when a message is handled.

\section{Starting additional local nodes after boot}
\label{sec:start-addit-local}

After booting a new \scalaris-System as described in
Section~\sieheref{sec.boot}, ten additional local nodes can be started
by typing \code{admin:add_nodes(10)} in the Erlang-Shell that the boot
process opened~\footnote{Increase the log level to {\tt info} to get
  the detailed startup logs. See Sect.~\sieheref{sec:logging}}.


\lstset{language=Erlang}
\begin{lstlisting}
scalaris/bin> ./boot.sh
[...]
=INFO REPORT==== 12-May-2009::16:24:18 ===
Yaws: Listening to 0.0.0.0:8000 for servers
 - http://localhost:8000 under ../docroot
[info] [ CC ] this() == {{127,0,0,1},14195}
[info] [ DNC <0.96.0> ] starting DeadNodeCache
[info] [ DNC <0.96.0> ] starting Dead Node Cache
[info] [ RM <0.97.0> ] starting ring maintainer

[info] [ RT <0.99.0> ] starting routingtable
[info] [ Node <0.101.0> ] joining 315238232250031455306327244779560426902
[info] [ Node <0.101.0> ] join as first 315238232250031455306327244779560426902
[info] [ FD <0.74.0> ] starting pinger for {{127,0,0,1},14195,<0.101.0>}
[info] [ Node <0.101.0> ] joined
[info] [ CY ] Cyclon spawn: {{127,0,0,1},14195,<0.102.0>}
(boot@csr-pc9)1> admin:add_nodes(10)
\end{lstlisting}

In the following we will trace, what this function does to join
additional nodes to the system.

The function \code{admin:add_nodes(int)} is defined as follows.

\codesnippet{admin.erl}{admin:add_nodes}{../src/admin.erl}

It calls \code{add_nodes_loop(Count, Delay)} with a delay of 0. This
function starts a new child for the main supervisor \code{main_sup}.
As defined by the parameters, to actually perform the start, the
function \code{cs_sup_or:start_link} is called by the Erlang
supervisor mechanism.  For more details on the OTP supervisor
mechanism see Chapter 18 of the Erlang book~\cite{erlang-book} or the
online documentation at
\url{http://www.erlang.org/doc/man/supervisor.html}.

\subsection{Supervisor-tree of a \scalaris{} node}

When starting a new node in the system, the following supervisor tree is
created:

\medskip
{\centering\includegraphics[width=0.9\linewidth]{supervision}}

\subsection{Starting the or-supervisor and general processes of a node}

The supervisor mechanism first calls the \code{init()} function of the
defined module (\code{cs_sup_or:init()} in this case) before calling the
defined start function (\code{start_link} here.

So, lets have a look at \code{cs_sup_or:init}, the 'Scalaris
\emph{or} supervisor'.

\codesnippet{cs_sup_or.erl}{cs_sup_or:init}{../src/cs_sup_or.erl}

The \code{init()} function must return process descriptions that the
supervisor should start, and how the processes have to be observed. Here, we
define a list of processes to be observed by a \code{one_for_one}
supervisor. The processes are: \code{Config}, \code{KeyHolder},
\code{MessageStatisticsCollector} and a \code{Supervisor_AND} process.

The term \code{\{one_for_one, 10, 1\}} defines that the supervisor should
  retry 10 times to restart each process before giving
  up. \code{one_for_one} supervision means, that if a single process stops,
  only that process is restarted. The other processes run independently.

The \code{cs_sup_or:init()} is finished and the supervisor
module, starts all the defined processes by calling their corresponding
\code{init()} functions and afterwards, the functions that were defined in
the list of the \code{cs_sup_or:init()}.

For a join of a new node, we are only interested in the starting of the
\code{Supervisor_AND} process here, which was the last one in the list. At
that point in time, all other defined processes are already started and
running.

\subsection{Starting the and-supervisor with a peer and its local database}

Again, the OTP will first call the \code{init()} function of the
corresponding module:

\codesnippet{cs_sup_and.erl}{cs_sup_and:init}{../src/cs_sup_and.erl}

It defines two processes, that have to be observed using an
\code{one_for_all}-supervisor, which means, that if one fails, all have to
be restarted. Passed to the \code{init} function is the \code{InstanceId}, a
random number to make nodes unique. It was calculated a bit earlier in
the code. Exercise: Try to find where.

As you can see from the list, the \code{DB} is started before the
\code{Node}. This is intended and important, because \code{cs_node} uses the
database, but not vice versa.

After the \code{cs_sup_and:init()} finished, the DB is initialized and
afterwards \code{cs_node:start_link} is called by the and-supervisor.
We only go into details here, for the latter.

\codesnippet{cs_node.erl}{cs_node:start_link}{../src/cs_node.erl}

This spawns a new process, that executes \code{cs_node:start()} and
maintains a link to that process. This function is called in the context of
the and-supervisor process, so the and-supervisor process will be informed,
when the spawned process finishes. After the spawn is submitted,
\code{cs_node:start_link} returns to the supervisor, which starts observing
the processes in a loop.

Note: \code{?MODULE} is a predefined Erlang macro, which expands to the
module name, the code belongs to (here: \code{cs_node}).

\subsection{Initializing a \code{cs_node}-process}

\codesnippet{cs_node.erl}{cs_node:start}{../src/cs_node.erl}

A \code{cs_node} first registers itself in the process dictionary.  Then,
the process sleeps for a random amount of time. Otherwise, if you would
start 1000 processes with \code{admin:add_nodes(1000)}, the boot-server
would receive many join requests at the same time, which is not intended.

Then, the node retrieves its \code{Id} from the keyholder: \code{Id =
  cs_keyholder:get_key()}. In the first call, a random identifier is
returned, otherwise the latest set value. If the \code{cs_node}-process
failed and is restarted by its supervisor, this call to the keyholder
ensures, that the node still keeps its \code{Id}, assuming that the
keyholder process is not failing.  This is important for the load-balancing
and for consistent responsibility of nodes to ensure consistent lookup in
the structured overlay. Note: the name \code{Key-holder} actually is an
id-holder.

If a node changes its position in the ring for load-balancing, the
key-holder will be informed and the \code{cs_node} finishes itself. This
triggers a restart of the corresponding database process via the
and-supervisor.  When the supervisor restarts both processes, they will
retrieve the new position in the ring from the key-holder and join the ring
there.

\todo{The supervisor was configured to restart a node at most 10 times. Does
  that mean, that a node can only change its position in the ring 10 times
  (caused by load-balancing)?}

Next, the \code{cs_node} registers itself as the owner of the
failuredetector \code{failuredetector:set_owner(self())} to become informed,
when the failuredetector detects failing nodes.

With \code{boot_server:connect()} a connection to the boot-server is
established.

\subsection{Actually joining the ring}

\code{cs_join:join} is called next in \code{cs_node:start()}.

\codesnippet{cs_join.erl}{cs_join:join}{../src/cs_join.erl}

The boot-server is contacted to retrieve the known number of nodes in the
ring. If the ring is empty, \code{join_first} is called. Otherwise,
\code{join_ring} is called.

\code{join_first} just creates a new state for a \scalaris{} node consisting
of an empty routing table, a successorlist containing itself, itself as its
predecessor, a reference to itself, its responsibility area from \code{Id}
to \code{Id} (the full ring), and a load balancing schema.

\codesnippet{cs_join.erl}{cs_join:join_first}{../src/cs_join.erl}

The macro \code{?RT} maps to the configured routing algorithm. It is defined
in \code{chordsharp.erl}. For further details on the routing see Chapter~\sieheref{chapter.routing}.

The state is defined in

\codesnippet{cs_state.erl}{cs_state:state}{../src/cs_state.erl}

If a node joins an existing ring, \code{reliable_get_node} for the own
\code{Id} is called in \code{cs_join:join()}. This lookup delivers the
successor for the joining node. The node, that is currently responsible for
\code{Id}, but which has a larger \code{Id} itself.  If this lookup fails
for some reason, it is tried again, by recursivly calling the \code{join()}.

\todo{What, if the \code{Id} is exactly the same as that of the existing
  node? This could lead to lookup and responsibility inconsistency? Can this
  be triggered by the load-balancing? This is a bug, that should be
  fixed!!!}

Then, \code{cs_join:join_ring} is called:

\codesnippet{cs_join.erl}{cs_join:join_ring}{../src/cs_join.erl}

First the node is initialized. Then it sends a \code{join} message to the
successor including a reference to itself and the chosen \code{Id}.

The message is received by the old node in \code{cs_node.erl}. There exists
a \code{\{join, X\}} handler.

\codesnippet{cs_node.erl}{cs_node:join_message}{../src/cs_node.erl}

This triggers to call \code{join_request} on the old node. 

\codesnippet{cs_join.erl}{cs_join:join_request}{../src/cs_join.erl}

This resets the local predecessor to the new node and splits the data.
Then it sends a \code{join_response} to the new node with its former
predecessor, the data, it has to host, and its successorlist.
Additionally, the new node will be observed by the failuredetector.

Note: Here, the observation of the former predecessor could be deleted from
the failure detector. But periodically, all known hosts are reregistered
with the failure detector, and then all other nodes are thrown away from the
list of nodes to observe in the failure detector. So, we do not care here.

Finally, the new predecessor is set and the \code{join_request()} is finished.
 
Back on the new node: it waits for the \code{join_response} message in
\code{cs_join:join_ring()}. The next steps after the message was received
from the old node are to register the predecessor, to register all new nodes
in the failure detector, to send a message to the predecessor, that its
successor has changed.

Finally, all data are added to the database and the succlist is build by
putting the successor to the head of the successor list of the successor
(old node): \code{[Succ | SuccList]}.

The next step in \code{cs_join:join()} is to call
\code{cs_reregister:reregister} which reregisters the node periodically with
the boot server. Then \code{\{false, State\}} is returned, which means 'this
was not the first node in the ring'. Now, the \code{cs_join:join()} is
completed.

\subsection{Beginning to serve requests}

\code{cs_join:join()} was called from \code{cs_node:start()}, which
now continues

\codesnippet{cs_node.erl}{cs_node:start}{../src/cs_node.erl}

The \code{cs_replica_stabilization:recreate_replicas()} function is called,
which is not yet implemented. It would recreated necessary replicas that
were lost due to load-balancing and node failures.

Finally all the self-management services are started with
\code{timer:after} and the loop for request handling is started. 

\subsection{FAQ}

\paragraph{Question:} How are the routing-table, load-balancing and paxos 
  processes started, that can be seen in the supervisor tree?

  \paragraph{Answer:} They are currently not implemented as separate Erlang
  processes. All the requests are handled by the loop started by
  \code{cs_node:start()}. Nevertheless, they could be implemented as
  separate processes to make the software architecture cleaner.

\chapter{Routing and routing tables in the Overlay}
\label{chapter.routing}

\hfill\emph{2008-07-25, SVN revision 12}

Each node of the ring can perform searches in the overlay.

A search is done by a lookup in the overlay, but there are several other
demands for communication between peers, so \scalaris{} provides a general
interface to route a message another peer, that is currently responsible for
a given \code{key}.

\begin{lstlisting}[title=\filetitle{cs_lookup.erl}]
[...]
unreliable_lookup(Key, Msg) ->
    get_pid(cs_node) ! {lookup_aux, Key, Msg}.

unreliable_get_key(Key) ->
    unreliable_lookup(Key, {get_key, cs_send:this(), Key}).
[...]
\end{lstlisting}

The message \code{Msg} could be a \code{get} which retrieves content from
the responsible node or a \code{get_node} message, which returns a pointer
to the node.

All currently supported messages are listed in the file \code{cs_node.erl}.

The message routing is implemented in lookup.erl

\begin{lstlisting}[title=\filetitle{lookup.erl}]
[...]
lookup_fin(Msg) ->
    self() ! Msg.

lookup_aux(State, Key, Msg) ->
    Terminate = util:is_between(cs_state:id(State), Key, cs_state:succ_id(State)),
    P = ?RT:next_hop(State, Key),
    ?LOG("[ ~w | I | Node   | ~w ] lookup_aux ~w ~w ~s~n",
      [calendar:universal_time(), self(), Terminate, P, Key]),
    if
	Terminate ->
	    cs_send:send(P, {lookup_fin, Msg});
	true ->
	    cs_send:send(P, {lookup_aux, Key, Msg})
    end.
[...]
\end{lstlisting}

Each node is responsible for a certain key interval. 
With the function \code{util:is_between} it is decided, whether the key is
between the current node and its successor. If that is the case, 
final step is done using \code{lookup_fin()}, which delivers the message to
the local node. Otherwise, the message is forwarded to the next nearest
known peer (listed in the routing table) determined by \code{?RT:next_hop}.


% \begin{lstlisting}[language=Java]
% interface RT {
%   foo();
%   lookup();
% }
% \end{lstlisting}

\code{routingtable.erl} is a generic interface for routing tables, like a
Java interface. In Erlang interfaces can be defined using a `behaviour'.
The files \code{rt_simple} and \code{rt_chord} implement the behaviour
`routingtable'.

The macro ?RT in other files replaces to the active module, which is defined
in \code{chordsharp.hrl}.

\begin{lstlisting}[title=\filetitle{chordsharp.hrl}]
[...]
%%This file determines which kind of routingtable is used. Uncomment the
%%one that is desired.

%%Standard Chord routingtable
-define(RT, rt_chord).

%%Simple routingtable
%-define(RT, rt_simple).
[...]
\end{lstlisting}

The functions, that have to be implemented for a routing mechanism are
defined in the following file:

\begin{lstlisting}[title=\filetitle{routingtable.erl}]
[...]
behaviour_info(callbacks) ->
    [
     % create a default routing table
     {empty, 1}, 
     % key space -> identifier space
     {hash_key, 1}, {getRandomNodeId, 0},
     % routing
     {next_hop, 2}, 
     % trigger for new stabilization round
     {stabilize, 1}, 
     % dead nodes filtering
     {filterDeadNodes, 2}, 
     % statistics
     {to_pid_list, 1}, {to_node_list, 1}, {get_size, 1},
     % for symmetric replication
     {get_keys_for_replicas, 1},
     % for debugging
     {dump, 1}
    ];

behaviour_info(_Other) ->
    undefined.
[...]
\end{lstlisting}

\begin{description}
\setlength{\parskip}{0pt}
\setlength{\itemsep}{0pt}
\item \code{empty/1} gets a successor passed and generates an empty routing
  table.  The data structure of the routing table is undefined. It can be a
  list, a tree, a matrix \ldots

\item \code{hash_key/1} gets a key and translates it to an id for the
  overlay.

\item \code{getrandomnodeid/0} returns a random node id.

\item \code{next_hop/2} gets a routing table and a key and returns the node,
  that should be contacted next (is nearest to the id).

\item \code{stabilize/1} is called periodically to rebuild the routing table.

\item \code{filterDeadNodes} is called by the failuredetector and tells the
  routing table about dead nodes to be eliminated from the routing
  table. This function cleans the routing table.

\item \code{to_pid_list/1} get all PIDs of the routing table entries.
\item \code{to_node_list/1} get all nodes in the routing table as complete
  reference including IP, range, etc.
\item \code{get_size/1} get the size of the routing table.

\item \code{get_keys_for_replicas/1} Returns for a given \code{Key} the keys
  of its replicas. Thereby one can implement successorlist replication or
  symmetric replication or any other schema.

\item \code{dump/1} dump the state. Not mandatory, may just return \code{ok}.
\end{description}

\section{Simple routing table}

One implementation of a routing table is the \code{rt_simple}, which routes
via the successor, which is inefficient, as it needs a linear number of hops
to reach its goal. A more robust implementation, would use a successor
list. This implementation is not very efficient on churn.

\subsection{Data types}
First, the data structure of the routing table is defined:
\begin{lstlisting}[title=\filetitle{rt_simple.erl}]
[...]
%% @type rt() = {node:node(), gb_trees:gb_tree()}. Sample routing table
%% @type key() = int(). Identifier
[...]
\end{lstlisting}
A routing table is a pair of a node (the successor) and an (unused) gbtree.
Keys in the overlay are identified by integers.

\subsection{A simple routingtable behaviour}

\begin{lstlisting}[title=\filetitle{rt_simple.erl}]
[...]
%% @doc creates an empty routing table.
%%      per default the empty routing should already include 
%%      the successor
%% @spec empty(node:node()) -> rt()
empty(Succ) ->
    {Succ, gb_trees:empty()}.
[...]
\end{lstlisting}
The empty routing table consists of the successor.

\begin{lstlisting}[title=\filetitle{rt_simple.erl}]
[...]
%% @doc hashes the key to the identifier space.
%% @spec hash_key(string()) -> key()
hash_key(Key) ->
    BitString = binary_to_list(crypto:md5(Key)),
    % binary to integer
    lists:foldl(fun(El, Total) -> (Total bsl 8) bor El end, 0, BitString).

%% @doc generates a random node id
%%      In this case it is a random 128-bit string.
%% @spec getRandomNodeId() -> key()
getRandomNodeId() ->
    % generates 128 bits of randomness
    hash_key(integer_to_list(random:uniform(65536 * 65536))).
[...]
\end{lstlisting}
Keys are hashed using MD5 and have a length of 128 bits.

\begin{lstlisting}[title=\filetitle{rt_simple.erl}]
[...]
%% @doc returns the next hop to contact for a lookup
%% @spec next_hop(cs_state:state(), key()) -> pid()
next_hop(State, _Key) ->
    cs_state:succ_pid(State).
[...]
\end{lstlisting}
Next hop is always the successor.

\begin{lstlisting}[title=\filetitle{rt_simple.erl}]
[...]
%% @doc triggers a new stabilization round
%% @spec stabilize(cs_state:state()) -> cs_state:state()
stabilize(State) ->
    % trigger the next stabilization round
    timer:send_after(config:pointerStabilizationInterval(), self(), {stabilize_pointers}),
    % renew routing table
    cs_state:set_rt(State, empty(cs_state:succ(State))).
[...]
\end{lstlisting}
The \code{stabilize/1} first triggers to be called again after the pointer
stabilization interval defined in the configuration. Then it resets its
routing table with the current successor.

\begin{lstlisting}[title=\filetitle{rt_simple.erl}]
[...]
%% @doc removes dead nodes from the routing table
%% @spec filterDeadNodes(rt(), [node:node()]) -> rt()
filterDeadNodes(RT, _DeadNodes) ->
    RT.
[...]
\end{lstlisting}
\code{FilterDeadNodes/2} does nothing, as only the successor is listed in
the routing table and that is reset periodically in \code{stabilize/1}.

\begin{lstlisting}[title=\filetitle{rt_simple.erl}]
[...]
%% @doc returns the pids of the routing table entries .
%% @spec to_pid_list(rt()) -> [pid()]
to_pid_list({Succ, _RoutingTable} = _RT) ->
    [node:pidX(Succ)].
[...]
\end{lstlisting}
\code{to_pid_list/1} return the pids of the routing tables, as defined in \code{node.erl}.

\begin{lstlisting}[title=\filetitle{rt_simple.erl}]
[...]
%% @doc returns the pids of the routing table entries .
%% @spec to_node_list(rt()) -> [node:node()]
to_node_list({Succ, _RoutingTable} = _RT) ->
    [Succ].
[...]
\end{lstlisting}
Return whole node definitions as defined in \code{node.erl}

\begin{lstlisting}[title=\filetitle{node.erl}]
[...]
-record(node, {pid, id, uniqueId}).
[...]
\end{lstlisting}

\begin{lstlisting}[title=\filetitle{node.erl}]
[...]
%% @doc returns the size of the routing table.
%%      inefficient standard implementation
%% @spec get_size(rt()) -> int()
get_size(RT) ->
    length(to_pid_list(RT)).
    
%% @doc returns the replicas of the given key
%% @spec get_keys_for_replicas(key() | string()) -> [key()]
get_keys_for_replicas(Key) when is_integer(Key) ->
    [Key, 
     normalize(Key + 16#40000000000000000000000000000000),
     normalize(Key + 16#80000000000000000000000000000000),
     normalize(Key + 16#C0000000000000000000000000000000)
    ];
get_keys_for_replicas(Key) when is_list(Key) ->
    get_keys_for_replicas(hash_key(Key)).

normalize(Key) ->
    Key band 16#FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF.
[...]
\end{lstlisting}

The \code{get_keys_for_replicas/1} implements symmetric replication, here.
The call to \code{normalize} implements the modulo by throwing high bits
away.

\begin{lstlisting}[title=\filetitle{node.erl}]
[...]
%% @doc 
%% @spec dump(cs_state:state()) -> term()
dump(_State) ->
    ok.
[...]
\end{lstlisting}

\code{dump/1} is not implemented.


\section{Chord routing table}

The file \code{rt_chord.erl} implements Chord's routing.

\subsection{Data types}

\begin{lstlisting}[title=\filetitle{node.erl}]
[...]
%% @type rt() = gb_trees:gb_tree(). Chord routing table
%% @type key() = int(). Identifier
[...]
\end{lstlisting}
The routing table is a \code{gb_tree}. Identifiers in the ring are integers.

\subsection{The routingtable behaviour for Chord}

\begin{lstlisting}[title=\filetitle{node.erl}]
[...]
%% @doc creates an empty routing table.
%% @spec empty(node:node()) -> rt()
empty(_Succ) ->
    gb_trees:empty().
[...]
\end{lstlisting}

\todo{This function should return \code{_Succ}?}

\code{hash_key(Key)} and \code{getRandomNodeId} call their counterparts from
\code{rt_simple.erl}

\begin{lstlisting}[title=\filetitle{rt_chord.erl}]
[...]
%% @doc returns the next hop to contact for a lookup
%% @spec next_hop(cs_state:state(), key()) -> node()
next_hop(State, Id) -> 
    case util:is_between(cs_state:id(State), Id, cs_state:succ_id(State)) of
	%succ is responsible for the key
	true ->
	    cs_state:succ_pid(State);
	% check routing table
	false ->
	    RT = cs_state:rt(State),
	    next_hop(cs_state:id(State), RT, Id, 127, cs_state:succ_pid(State))
    end.
[...]
\end{lstlisting}

\code{next_hop} traverses the routing table beginning with the longest
finger ($2^{127}$) by calling the helper function \code{next_hop/5}.

\begin{lstlisting}[title=\filetitle{rt_chord.erl}]
[...]
% @private
next_hop(N, RT, Id, Index, Candidate) ->
    case gb_trees:is_defined(Index, RT) of
	true ->
	    case gb_trees:get(Index, RT) of
		null ->
		    Candidate;
		Entry ->
		    case util:is_between_closed(N, node:id(Entry), Id) of
			true ->
			    node:pidX(Entry);
			false ->
			    next_hop(N, RT, Id, Index - 1, Candidate)
		    end
		end;
	false ->
	    Candidate
    end.
[...]
\end{lstlisting}

If the entry exists, it is retrieved from the \code{gb_tree}.  If the id of
the routing table entry is between ourselves and the searched id, the finger
is chosen. If anything fails, \code{Candidate} (the successor) is chosen.

Why could a routing table entry be \code{null}? \code{filterDeadNodes}
changes entries to \code{null}.

\todo{BUG: Instead of directly returning \code{Candidate} one should further
  traverse the routing table for shorter appropriate fingers. If doing so, a
  check whether \code{Index} is zero, would become necessary.}

If the finger is to long, recursivly try the next shorter finger.

\begin{lstlisting}[title=\filetitle{rt_chord.erl}]
[...]
%% @doc starts the stabilization routine
%% @spec stabilize(cs_state:state()) -> cs_state:state()
stabilize(State) ->
    % trigger the next stabilization round
    timer:send_after(config:pointerStabilizationInterval(), self(), {stabilize_pointers}),
    % calculate the longest finger
    Key = calculateKey(State, 127),
    % trigger a lookup for Key
    cs_lookup:unreliable_lookup(Key, {rt_get_node, cs_send:this(), 127}),
    State.
[...]
calculateKey(State, Idx) ->
    % n + 2^Idx
    rt_simple:normalize(cs_state:id(State) + (1 bsl Idx)).
\end{lstlisting}

The routing table stabilization is triggered with the index 127 and then
runs asynchronously, as we do not want to block the \code{cs_node} to
perform other request while recalculating the routing table.

We have to find the node responsible for the calculated finger and therefore
perform a lookup for the node with a \code{rt_get_node} message, including
a reference to ourselves as the reply-to address and the index to be set.

The lookup performs an overlay routing by passing the massage until the
responsible node is found. There, the message is delivered to the
\code{cs_node}.

At the destination the message is handled in \code{cs_node.erl}:

\begin{lstlisting}[title=\filetitle{cs_node.erl}]
[...]
	% for chord_rt
	{rt_get_node, Source_PID, Idx} ->
	    cs_send:send(Source_PID, {rt_get_node_response, Idx, cs_state:me(State)}),
	    loop(State, ?DEBUG(Debug));

	{rt_get_node_response, Index, Node} = _Message ->
	    NewState = ?RT:stabilize(State, Index, Node),
	    loop(NewState, ?DEBUG(cs_debug:debug(Debug, NewState, _Message)));
[...]
\end{lstlisting}

The remote node just sends the requested information back directly in a
\code{rt_get_node_response} message including a reference to itself.

When receiving the routing table entry, we call \code{stabilize/3}!, which
is different from the \code{stabilize/1} above.

\begin{lstlisting}[title=\filetitle{rt_chord.erl}]
[...]
stabilize(State, Index, Node) ->
    RT = cs_state:rt(State),
    case node:is_null(Node) of
	true ->
	    State;
	false ->
	    case cs_state:succ(State) == Node of
		true ->
		    State;
		false ->
		    NewRT = gb_trees:enter(Index, Node, RT),
		    Key = calculateKey(State, Index - 1),
		    self() ! {lookup_aux, Key, {rt_get_node, cs_send:this(), Index - 1}},
		    cs_state:set_rt(State, NewRT)
	    end
    end.
[...]
\end{lstlisting}

\code{stabilize/3} assigns the received routing table entry and triggers to
fill the next shorter one using the same mechanisms as described.

When the shortest finger is the successor, then filling the routing table is
stopped, as no further new entries would occur. It is not necessary, that
\code{Index} reaches 1 to make that happen. If less than $2^{128}$ nodes
participate in the system, it may happen earlier.

\code{filterDeadNodes} updates the \code{gb_tree} accordingly. 
\begin{lstlisting}[title=\filetitle{rt_chord.erl}]
[...]
%% @doc remove all entries with the given ids
%% @spec filterDeadNodes(gb_trees:gb_tree(), term()) -> gb_trees:gb_tree()
filterDeadNodes(RT, DeadNodes) ->
    gb_sets:fold(fun (Id, RT2) -> filter_intern(gb_trees:iterator(RT2), RT2, Id) end, RT, DeadNodes).

% @private
filter_intern(nil, RT, _) ->
    RT;
filter_intern([], RT, _) ->
    RT;
filter_intern(Iterator, RT, Id) ->
    {Index, Value, Next} = gb_trees:next(Iterator),
    case node:uniqueId(Value) == Id of
	true ->
	    filter_intern(Next, gb_trees:delete(Index, RT), Id);
	false ->
	    filter_intern(Next, RT, Id)
    end.


%% @doc returns the pids of the routing table entries .
%% @spec to_pid_list(rt()) -> [pid()]
to_pid_list(RT) ->
    lists:map(fun ({_Idx, Node}) -> node:pidX(Node) end, gb_trees:to_list(RT)).

%% @doc returns the pids of the routing table entries .
%% @spec to_node_list(rt()) -> [node:node()]
to_node_list(RT) ->
    lists:map(fun ({_Idx, Node}) -> Node end, gb_trees:to_list(RT)).

%% @doc returns the size of the routing table.
%%      inefficient standard implementation
%% @spec get_size(rt()) -> int()
get_size(RT) ->
    length(to_pid_list(RT)).
    
%% @doc returns the replicas of the given key
%% @spec get_keys_for_replicas(key() | string()) -> [key()]
get_keys_for_replicas(Key) ->
    rt_simple:get_keys_for_replicas(Key).
[...]
\end{lstlisting}

Also the remaining functions are implemented as one would expect.


\chapter{Directory Structure of the Source Code}

The directory tree of \scalaris{} is structured as follows: \\

\begin{tabular}{|r|p{11.5cm}|}
 \hline
 \code{bin} & contains shell scripts needed to work with \scalaris{} (e.g.\ start the boot services, start a node, \dots)\\
 \code{contrib} & necessary third party packages \\
 \code{doc} & generated erlang documentation \\
 \code{docroot} & root directory of the integrated webserver \\
 \code{java-api} & a java api to \scalaris{} \\
 \code{log} & log files \\
 \code{src} & contains the \scalaris{} source code\\
 \code{tests} & unit tests for \scalaris{} \\
 \code{user-dev-guide} & contains the sources for this document\\
 \hline
\end{tabular}

\chapter{System Components}



\chapter{Processes}

\chapter{Troubleshooting}

\section{ApplicationMonitor appmon:start()}



\appendix

\chapter{Java API}

\section{de.zib.chordsharp.ChordSharp}

\begin{lstlisting}[language=Java, morekeywords={bool}]
public class ChordSharp
\end{lstlisting}

Public ChordSharp Interface. 
\\

\begin{description}
\item[\textbf{Version:}]1.1
\item[\textbf{Author:}]Nico Kruber, kruber@zib.de
\end{description}

\begin{tabular}{|l|l|}
\hline 
 \textbf{Method Summary}
 & \\
 \hline 
 static Vector$<$String$>$ &\textbf{getSubscribers}(String topic)\\ 
& Gets a list of subscribers of a topic. \\
 \hline 
 static void &\textbf{publish}(String topic, String content)\\ 
 & Publishes an event under a given topic. \\
 \hline 
 static String &\textbf{read}(String key)\\ 
 & Gets the value stored with the given key. \\
 \hline 
 static void &\textbf{subscribe}(String topic, String url)\\ 
 & Subscribes a url for a topic. \\
 \hline 
 static void &\textbf{write}(String key, String value)\\ 
 & Stores the given key/value pair. \\
 \hline 

\end{tabular}

\subsection*{ read}
\begin{lstlisting}[language=Java, morekeywords={bool}]
public static String read(String key)
                   throws ConnectionException,
                          TimeoutException,
                          UnknownException,
                          NotFoundException
\end{lstlisting}

Gets the value stored with the given key. 

 

\begin{description}
\item[\textbf{Parameters:}]key - the key to look up 
\item[\textbf{Returns:}]the value stored under the given key
\item[\textbf{Throws:}]
\end{description}
\begin{tabular}{ll}
ConnectionException & if the connection is not active or a \\
& communication error occurs or an exit signal \\
& was received or the remote node sends a \\
& message containing an invalid cookie \\
TimeoutException & if a timeout occurred while trying to fetch the \\
& value \\
NotFoundException & if the requested key does not exist \\
UnknownException & if any other error occurs\\
\end{tabular}


\subsection*{ write}
\begin{lstlisting}[language=Java, morekeywords={bool, throws}]

public static void write(String key,
                         String value)
                  throws ConnectionException,
                         TimeoutException,
                         UnknownException
\end{lstlisting}
Stores the given key/value pair. 

 

\begin{description}
\item[\textbf{Parameters:}]key - the key to store the value for
value - the value to store 
\item[\textbf{Throws:}]ConnectionException - if the connection is not active or a communication error occurs or an exit signal was received or the remote node sends a message containing an invalid cookie 
TimeoutException - if a timeout occurred while trying to write the value 
UnknownException - if any other error occurs

\end{description}


\subsection*{ publish}
\begin{lstlisting}[language=Java, morekeywords={bool, throws}]

public static void publish(String topic,
                           String content)
                    throws ConnectionException
\end{lstlisting}
Publishes an event under a given topic. 

 

\begin{description}
\item[\textbf{Parameters:}]topic - the topic to publish the content under
content - the content to publish 
\item[\textbf{Throws:}]ConnectionException - if the connection is not active or a communication error occurs or an exit signal was received or the remote node sends a message containing an invalid cookie
\end{description}

\subsection*{ subscribe}
\begin{lstlisting}[language=Java, morekeywords={bool, throws}]

public static void subscribe(String topic,
                             String url)
                      throws ConnectionException
\end{lstlisting}
Subscribes a url for a topic. 

 

\begin{description}
\item[\textbf{Parameters:}]topic - the topic to subscribe the url for
url - the url of the subscriber (this is where the events are send to) 
\item[\textbf{Throws:}]ConnectionException - if the connection is not active or a communication error occurs or an exit signal was received or the remote node sends a message containing an invalid cookie

\end{description}


\subsection*{ getSubscribers}
\begin{lstlisting}[language=Java, morekeywords={bool, throws}]

public static Vector<String> getSubscribers(String topic)
                                     throws ConnectionException,
                                            UnknownException
\end{lstlisting}
Gets a list of subscribers of a topic. 

 

\begin{description}
\item[\textbf{Parameters:}]topic - the topic to get the subscribers for 
\item[\textbf{Returns:}]the subscriber URLs 
\item[\textbf{Throws:}]ConnectionException - if the connection is not active or a communication error occurs or an exit signal was received or the remote node sends a message containing an invalid cookie 
UnknownException - is thrown if the return type of the erlang method does not match the expected one

\end{description}

\subsection*{ de.zib.chordsharp.Transaction}


\begin{lstlisting}[language=Java, morekeywords={bool}]
public class \textbf{Transaction}
\end{lstlisting}



  Provides means to realise a transaction with the chordsharp ring using Java. 


  It reads the connection parameters from a file called ChordSharpConnection.properties or uses default properties defined in ChordSharpConnection.defaultProperties. 
\begin{lstlisting}[language=Java, morekeywords={bool}]
OtpErlangString otpKey; 
OtpErlangString otpValue; 
OtpErlangString otpResult; 
String key; 
String value; 
String result; 

Transaction transaction = new Transaction(); // Transaction() 
transaction.start(); // start() 
transaction.write(otpKey, otpValue); // write(OtpErlangString, OtpErlangString) 
transaction.write(key, value); // write(String, String) 
otpResult = transaction.read(otpKey); //read(OtpErlangString) 
result = transaction.read(key); //read(String) 
transaction.commit(); // commit() 
\end{lstlisting}

For more examples, have a look at TransactionReadExample,
TransactionParallelReadsExample, TransactionWriteExample and
TransactionReadWriteExample.

\subsubsection*{Attention:}

If a read or write operation fails within a transaction all subsequent
operations on that key will fail as well. This behaviour may
particularly be undesirable if a read operation just checks whether a
value already exists or not. To overcome this situation call
revertLastOp() immediately after the failed operation which restores
the state as it was before that operation.

The TransactionReadWriteExample example shows such a use case.


 


\begin{description}
\item[\textbf{Version:}]1.0
\item[\textbf{Author:}]Nico Kruber, kruber@zib.de
\end{description}

\begin{tabular}{|l|}
\hline 
 \textbf{Constructor Summary}
 \\
 \hline 
\textbf{Transaction}()\\ 
 Creates the object's connection to the chordsharp node specified in the \\
``ChordSharpConnection.properties'' file. \\
 \hline 

\end{tabular}

    

\begin{tabular}{|l|l|}
\hline 
 \textbf{Method Summary} & \\
 \hline 
  void &\textbf{abort}()\\ 
 & Cancels the current transaction. \\
 \hline 
  void &\textbf{commit}()\\ 
 & Commits the current transaction. \\
 \hline 
  OtpErlangString &\textbf{read}(OtpErlangString key)\\ 
 & Gets the value stored under the given key. \\
 \hline 
  String &\textbf{read}(String key)\\ 
 & Gets the value stored under the given key. \\
 \hline 
  void &\textbf{revertLastOp}()\\ 
 & Reverts the last (read or write) operation by \\
 & restoring the last state. \\
 \hline 
  void &\textbf{start}()\\ 
 & Starts a new transaction by generating a new transaction log. \\
 \hline 
  void &\textbf{write}(OtpErlangString key, OtpErlangString value)\\ 
 & Stores the given key/value pair. \\
 \hline 
  void &\textbf{write}(String key, String value)\\ 
 & Stores the given key/value pair. \\
 \hline 

\end{tabular}


\subsection*{Transaction}

\begin{lstlisting}[language=Java]
public Transaction()
            throws ConnectionException
\end{lstlisting}
Creates the object's connection to the chordsharp node specified in the ``ChordSharpConnection.properties'' file. 

\begin{description}
\item[\textbf{Throws:}]ConnectionException - if the connection fails
\end{description}

\subsection*{start}

\begin{lstlisting}[language=Java]
public void start()
           throws ConnectionException,
                  TransactionNotFinishedException,
                  UnknownException
\end{lstlisting}
Starts a new transaction by generating a new transaction log. 

 

\begin{description}
\item[\textbf{Throws:}]ConnectionException - if the connection is not active or a communication error occurs or an exit signal was received or the remote node sends a message containing an invalid cookie 
TransactionNotFinishedException - if an old transaction is not finished (via commit() or abort()) yet 
UnknownException - if the returned value from erlang does not have the expected type/structure

\end{description}


\subsection*{commit}

\begin{lstlisting}[language=Java]
public void commit()
            throws UnknownException,
                   ConnectionException
\end{lstlisting}
Commits the current transaction. The transaction's log is reset if the commit was successful, otherwise it still retains in the transaction which must be successfully committed or aborted in order to be restarted. 

 

\begin{description}
\item[\textbf{Throws:}
]UnknownException - If the commit fails or the returned value from erlang is of an unknown type/structure, this exception is thrown. Neither the transaction log nor the local operations buffer is emptied, so that the commit can be tried again. 
ConnectionException - if the connection is not active or a communication error occurs or an exit signal was received or the remote node sends a message containing an invalid cookie
\item[\textbf{See Also:}
]abort()

\end{description}

\subsection*{ abort}

\begin{lstlisting}[language=Java]
public void abort()
\end{lstlisting}
Cancels the current transaction. 

  For a transaction to be cancelled, only the transLog needs to be reset. Nothing else needs to be done since the data was not modified until the transaction was committed. 


 

\subsection*{read}

\begin{lstlisting}[language=Java] 
public OtpErlangString read(OtpErlangString key)
                     throws ConnectionException,
                            TimeoutException,
                            UnknownException,
                            NotFoundException
\end{lstlisting}
Gets the value stored under the given key. 

\begin{description}
\item[\textbf{Parameters:}
]key - the key to look up 
\item[\textbf{Returns:}
]the value stored under the given key
\item[\textbf{Throws:}
]ConnectionException - if the connection is not active or a communication error occurs or an exit signal was received or the remote node sends a message containing an invalid cookie 
TimeoutException - if a timeout occurred while trying to fetch the value 
NotFoundException - if the requested key does not exist 
UnknownException - if any other error occurs

\end{description}


\subsection*{read}

\begin{lstlisting}[language=Java]
public String read(String key)
            throws ConnectionException,
                   TimeoutException,
                   UnknownException,
                   NotFoundException
\end{lstlisting}
Gets the value stored under the given key. 

 

\begin{description}
\item[\textbf{Parameters:}
]key - the key to look up 
\item[\textbf{Returns:}
]the value stored under the given key
\item[\textbf{Throws:}
]ConnectionException - if the connection is not active or a communication error occurs or an exit signal was received or the remote node sends a message containing an invalid cookie 
TimeoutException - if a timeout occurred while trying to fetch the value 
NotFoundException - if the requested key does not exist 
UnknownException - if any other error occurs

\end{description}


\subsection*{write}

\begin{lstlisting}[language=Java] 
public void write(OtpErlangString key,
                  OtpErlangString value)
           throws ConnectionException,
                  TimeoutException,
                  UnknownException
\end{lstlisting}
Stores the given key/value pair. 

\begin{description}
\item[\textbf{Parameters:}
]key - the key to store the value for
value - the value to store 
\item[\textbf{Throws:}
]ConnectionException - if the connection is not active or a communication error occurs or an exit signal was received or the remote node sends a message containing an invalid cookie 
TimeoutException - if a timeout occurred while trying to write the value 
UnknownException - if any other error occurs

\end{description}

\subsection*{write}

\begin{lstlisting}[language=Java] 
public void write(String key,
                  String value)
           throws ConnectionException,
                  TimeoutException,
                  UnknownException
\end{lstlisting}
Stores the given key/value pair. 

 

\begin{description}
\item[\textbf{Parameters:}]key - the key to store the value for
value - the value to store 
\item[\textbf{Throws:}]ConnectionException - if the connection is not active or a communication error occurs or an exit signal was received or the remote node sends a message containing an invalid cookie 
TimeoutException - if a timeout occurred while trying to write the value 
UnknownException - if any other error occurs

\end{description}


\subsection*{revertLastOp}

\begin{lstlisting}[language=Java] 
public void revertLastOp()
\end{lstlisting}

Reverts the last (read, parallelRead or write) operation by restoring
the last state. If no operation was initiated yet, this method does
nothing.

This method is especially useful if after an unsuccessful read a value
with the same key should be written which is not possible if the
failed read is still in the transaction's log.

\bibliographystyle{plainnat}

\begin{thebibliography}{9}

\bibitem{erlang-book}
J. Armstrong.
\newblock \emph{Programming Erlang: Software for a Concurrent World.}
\newblock Pragmatic Programmers, ISBN: 978-1-9343560-0-5, July 2007
\end{thebibliography}

\end{document}
%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 
