%  Copyright 2007-2008 Konrad-Zuse-Zentrum für Informationstechnik Berlin
%
%   Licensed under the Apache License, Version 2.0 (the "License");
%   you may not use this file except in compliance with the License.
%   You may obtain a copy of the License at
%
%       http://www.apache.org/licenses/LICENSE-2.0
%
%   Unless required by applicable law or agreed to in writing, software
%   distributed under the License is distributed on an "AS IS" BASIS,
%   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
%   See the License for the specific language governing permissions and
%   limitations under the License.
%%%-------------------------------------------------------------------
%%% File    : failuredetector.erl
%%% Author  : Thorsten Schuett <schuett@zib.de>
%%% Description : Failure detector based on Guerraoui
%%%
%%% Created :  3 May 2007 by Thorsten Schuett <schuett@zib.de>
%%%-------------------------------------------------------------------
%% @author Thorsten Schuett <schuett@zib.de>
%% @copyright 2007-2008 Konrad-Zuse-Zentrum für Informationstechnik Berlin
%% @version $Id$
-module(failuredetector).

-author('schuett@zib.de').
-vsn('$Id$ ').

-export([start_link/1, start/1, set_owner/1, add_node/3, add_nodes/1, set_nodes/1, 
	 node_count/0, remove_node/1]).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Public Interface
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% @private
get_pid() ->
    process_dictionary:lookup_process(erlang:get(instance_id), failure_detector).

%% @doc sets the owner of this failure detector. The owner will get the crash messages generated by it.
%% @spec set_owner(pid()) -> ok
set_owner(Owner) ->
    %io:format("[ I | Fail   | ~w ] set owner: ~w~n",[self(), self()]),
    get_pid() ! {set_owner, Owner},
    ok.

%% @doc adds a node which should be watched. Id has to be a unique identifier for this process. Tag can 
%%      used as a human readable name.
%% @spec add_node(Id, Tag, pid()) -> ok
%%  Id = term()
%%  Tag = term()
add_node(Id, Tag, Node) ->
    %io:format("[ I | Fail   | ~w ] add node: ~w~n",[self(), Node]),
    get_pid() ! {add_node, Id, Tag, Node},
    ok.

%% @doc adds a list of nodes which should be watched. 
%% @see failuredetector:add_node/3
%% @spec add_nodes(list(T)) -> ok
%%  T = {Id, Tag, pid()}
add_nodes(Nodes) ->
    %io:format("[ I | Fail   | ~w ] add nodes: ~w~n",[self(), Nodes]),
    get_pid() ! {add_nodes, Nodes},
    ok.

%% @doc replaces the nodes to be watched with the new passed nodes. 
%% @see failuredetector:add_node/3
%% @spec set_nodes(list(T)) -> ok
%%  T = {Id, Tag, pid()}
set_nodes(Nodes) ->
    %io:format("[ I | Fail   | ~w ] set nodes: ~w~n",[self(), Nodes]),
    get_pid() ! {set_nodes, Nodes}.

%% @doc the number of nodes under surveillance
%% @spec node_count() -> int()
node_count() ->
    get_pid() ! {get_node_count, self()},
    receive
	{get_node_count_response, Count} ->
	    Count
    end.
    
%% @doc remove a node from the failure detector
remove_node(Id) ->
    get_pid() ! {remove_node, Id}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Implementation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% trigger nodes
trigger([], _, _, _) ->
    ok;
trigger(Cur, Alive, Tags, Owner) ->
    {Id, Pid, Next} = gb_trees:next(Cur),
    IsAlive = gb_sets:is_element(Id, Alive),
    if
	not IsAlive ->
	    %io:format("crash ~w~n", [Pid]),
	    Owner ! {crash, Id, gb_trees:get(Id, Tags), Pid},
	    trigger(Next, Alive, Tags, Owner);
	true ->
	    cs_send:send(Pid, {ping, cs_send:this(), Id}),
	    trigger(Next, Alive, Tags, Owner)
    end.

% ping nodes
ping_nodes(Nodes) ->
    lists:foreach(fun ({Id, Pid}) ->
			  cs_send:send(Pid, {ping, cs_send:this(), Id})
		  end,
		  gb_trees:to_list(Nodes)).

% add nodes
add_nodes(NewNodes, Nodes, Alive, Tags) ->
    {lists:foldl(fun ({Id,   _, Pid}, Sum) -> gb_trees:enter(Id, Pid, Sum) end, Nodes, NewNodes), 
     lists:foldl(fun ({Id,   _,   _}, Sum) -> gb_sets:add(Id, Sum)         end, Alive, NewNodes),
     lists:foldl(fun ({Id, Tag,   _}, Sum) -> gb_trees:enter(Id, Tag, Sum) end, Tags,  NewNodes)}.

% set nodes
set_nodes(NewNodes, OldNodes, Alive) ->
    {lists:foldl(fun ({Id, _, Pid}, Sum) -> gb_trees:enter(Id, Pid, Sum) end, gb_trees:empty(), NewNodes),
     lists:foldl(fun ({Id, _, _}, Sum) -> 
			 IsOldNode = gb_trees:is_defined(Id, OldNodes),
			 if
			     IsOldNode ->
				 Sum;
			     true ->
				 gb_sets:add(Id, Sum) 
			 end
		 end, 
		 Alive, NewNodes),
    lists:foldl(fun ({Id, Tag,   _}, Sum) -> gb_trees:enter(Id, Tag, Sum) end, gb_trees:empty(),  NewNodes)}.
    
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Main loop
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Nodes: Id -> Pid
%% Alive: set<Id>
%% Owner: Pid

%% @spec loop(gb_trees:gb_tree(), gb_sets:gb_set(), gb_trees:gb_tree(), pid()) -> ok
loop(Nodes, Alive, Tags, Owner) ->
    receive
	{remove_node, Id} ->
	    loop(gb_trees:delete_any(Id, Nodes), gb_sets:delete_any(Id, Alive), gb_trees:delete_any(Id, Tags), Owner);
	{get_node_count, PID} ->
	    PID ! {get_node_count_response, gb_trees:size(Nodes)},
	    loop(Nodes, Alive, Tags, Owner);
	{add_node, Id, Tag, Node} ->
	    loop(gb_trees:enter(Id, Node, Nodes), gb_sets:add(Id, Alive), 
		 gb_trees:enter(Id, Tag, Tags), Owner);

	{add_nodes, NewNodes} ->
	    {Nodes_, Alive_, Tags_} = add_nodes(NewNodes, Nodes, Alive, Tags),
	    loop(Nodes_, Alive_, Tags_, Owner);

	{set_nodes, NewNodes} ->
	    {Nodes_, Alive_, Tags_} = set_nodes(NewNodes, Nodes, Alive),
	    loop(Nodes_, Alive_, Tags_, Owner);

	{timeout} -> 
	    trigger(gb_trees:iterator(Nodes), Alive, Tags, Owner),
	    timer:send_after(config:failureDetectorInterval(), self(), {timeout}),
	    loop(Nodes, gb_sets:new(), Tags, Owner);

	{ping_timeout} -> 
	    timer:send_after(config:failureDetectorPingInterval(), self(), {ping_timeout}),
	    ping_nodes(Nodes),
	    loop(Nodes, Alive, Tags, Owner);

	{pong, Id} ->
	    loop(Nodes, gb_sets:add(Id, Alive), Tags, Owner);

	{set_owner, NewOwner} ->
	    loop(Nodes, Alive, Tags, NewOwner);

	{'$gen_cast',{debug_info,Requestor}} ->
	    Requestor ! {debug_info_response, [{"nodes", gb_trees:size(Nodes)}, {"alive", gb_sets:size(Alive)}]},
	    loop(Nodes, Alive, Tags, Owner);

	X ->
	    io:format("[ W | Fail   | ~w ] unknown message: ~w~n",[self(), X]),
	    loop(Nodes, Alive, Tags, Owner)
    end.

%% @doc starts the main loop
%% @spec start(term()) -> term()
start(InstanceId) ->
    %io:format("[ I | Fail   | ~w ] start detector~n",[self()]),
    %register(failure_detector, self()),
    process_dictionary:register_process(InstanceId, failure_detector, self()),
    timer:send_after(config:failureDetectorInterval(), self(), {timeout}),
    timer:send_after(config:failureDetectorPingInterval(), self(), {ping_timeout}),
    loop(gb_trees:empty(), gb_sets:new(), gb_trees:empty(), failure_detector).

%% @doc spawns a failuredetector
%% @spec start_link(term()) -> {ok, pid()}
start_link(InstanceId) ->
    {ok, spawn_link(?MODULE, start, [InstanceId])}.
